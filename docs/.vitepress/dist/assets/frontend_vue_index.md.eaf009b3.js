import{_ as s,c as n,o as a,a as l}from"./app.248772be.js";const d=JSON.parse('{"title":"指南","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue2 VS Vue3","slug":"vue2-vs-vue3","link":"#vue2-vs-vue3","children":[]},{"level":2,"title":"Vue3 新特性","slug":"vue3-新特性","link":"#vue3-新特性","children":[{"level":3,"title":"重写双向数据绑定","slug":"重写双向数据绑定","link":"#重写双向数据绑定","children":[]},{"level":3,"title":"VDOM性能瓶颈","slug":"vdom性能瓶颈","link":"#vdom性能瓶颈","children":[]},{"level":3,"title":"Fragments","slug":"fragments","link":"#fragments","children":[]},{"level":3,"title":"Tree-Shaking","slug":"tree-shaking","link":"#tree-shaking","children":[]}]}],"relativePath":"frontend/vue/index.md"}'),e={name:"frontend/vue/index.md"},p=l(`<h1 id="指南" tabindex="-1">指南 <a class="header-anchor" href="#指南" aria-hidden="true">#</a></h1><p><a href="https://cn.vuejs.org/" target="_blank" rel="noreferrer">vue3 官方文档</a></p><p>MVVM(Model-View-ViewModel)架构</p><ol><li>View: 视图层</li><li>ViewModel: 业务逻辑层（一切js可视为业务逻辑）</li><li>Model: 数据层（存储数据及对数据的处理如增删改查）</li></ol><h2 id="vue2-vs-vue3" tabindex="-1">Vue2 VS Vue3 <a class="header-anchor" href="#vue2-vs-vue3" aria-hidden="true">#</a></h2><ul><li>选项时API 逻辑比较分散，可读性差，可维护性差</li><li>组合式API 逻辑分明，可维护性高</li></ul><h2 id="vue3-新特性" tabindex="-1">Vue3 新特性 <a class="header-anchor" href="#vue3-新特性" aria-hidden="true">#</a></h2><h3 id="重写双向数据绑定" tabindex="-1">重写双向数据绑定 <a class="header-anchor" href="#重写双向数据绑定" aria-hidden="true">#</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// vue2</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 基于Object.defineProperty()实现</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// vue3 基于Proxy</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// proxy与Object.defineProperty(obj, prop, desc)方式相比有以下优势：</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//丢掉麻烦的备份数据</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//省去for in 循环</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听数组变化</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//代码更简化</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听动态新增的属性；</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听删除的属性 ；</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听数组的索引和 length 属性；</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> proxyObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">get</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">prop</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prop</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">prop</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">set</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">value</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">prop</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">888</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h3 id="vdom性能瓶颈" tabindex="-1">VDOM性能瓶颈 <a class="header-anchor" href="#vdom性能瓶颈" aria-hidden="true">#</a></h3><p>在Vue2中,每次更新diff,都是全量对比,Vue3则只对比带有标记的,这样大大减少了非动态内容的对比消耗</p><p><a href="https://vue-next-template-explorer.netlify.app/" target="_blank" rel="noreferrer">Vue Template Explorer</a> 可以通过这个网站看到静态标记</p><p>新增 patch flag 标记</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#A6ACCD;">TEXT = 1 // 动态文本节点</span></span>
<span class="line"><span style="color:#A6ACCD;">CLASS=1&lt;&lt;1,1 // 2//动态class</span></span>
<span class="line"><span style="color:#A6ACCD;">STYLE=1&lt;&lt;2，// 4 //动态style</span></span>
<span class="line"><span style="color:#A6ACCD;">PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span>
<span class="line"><span style="color:#A6ACCD;">FULLPR0PS=1&lt;&lt;4,// 16 //具有动态key属性，当key改变时，需要进行完整的diff比较。</span></span>
<span class="line"><span style="color:#A6ACCD;">HYDRATE_ EVENTS = 1 &lt;&lt; 5，// 32 //带有监听事件的节点</span></span>
<span class="line"><span style="color:#A6ACCD;">STABLE FRAGMENT = 1 &lt;&lt; 6, // 64 //一个不会改变子节点顺序的fragment</span></span>
<span class="line"><span style="color:#A6ACCD;">KEYED_ FRAGMENT = 1 &lt;&lt; 7, // 128 //带有key属性的fragment 或部分子字节有key</span></span>
<span class="line"><span style="color:#A6ACCD;">UNKEYED FRAGMENT = 1&lt;&lt; 8, // 256 //子节点没有key 的fragment</span></span>
<span class="line"><span style="color:#A6ACCD;">NEED PATCH = 1 &lt;&lt; 9, // 512 //一个节点只会进行非props比较</span></span>
<span class="line"><span style="color:#A6ACCD;">DYNAMIC_SLOTS = 1 &lt;&lt; 10 // 1024 // 动态slot</span></span>
<span class="line"><span style="color:#A6ACCD;">HOISTED = -1 // 静态节点</span></span>
<span class="line"><span style="color:#A6ACCD;">BALL = -2</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="fragments" tabindex="-1">Fragments <a class="header-anchor" href="#fragments" aria-hidden="true">#</a></h3><ul><li>Vue3允许我们支持多个根节点</li><li>支持render JSX写法</li><li>同时新增了Suspense 和 多v-model用法</li></ul><h3 id="tree-shaking" tabindex="-1">Tree-Shaking <a class="header-anchor" href="#tree-shaking" aria-hidden="true">#</a></h3><p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p><p>在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p><p>而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果你不使用其某些功能，它们将不会包含在你的基础包中</p><p>就是比如你要用watch 就是import {watch} from &#39;vue&#39; 其他的computed 没用到就不会给你打包减少体积</p>`,21),t=[p];function o(r,c,i,y,A,C){return a(),n("div",null,t)}const F=s(e,[["render",o]]);export{d as __pageData,F as default};

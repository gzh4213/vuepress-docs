import{_ as p,c as e,o as a,a as i}from"./app.248772be.js";const m=JSON.parse('{"title":"前端性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/data/performance/index.md"}'),t={name:"frontend/data/performance/index.md"},n=i('<h1 id="前端性能优化" tabindex="-1">前端性能优化 <a class="header-anchor" href="#前端性能优化" aria-hidden="true">#</a></h1><p>现代浏览器网页当前基本都是前后端分离的开发模式，对于前端页面性能问题不仅跟服务端数据响应有关，跟前端静态资源的打包方式等方面也有很大关系</p><p>优化手段 目前常见的前端性能手段大概有以下几种：</p><p>在网络方面</p><p>1、HTTP 2.0 HTTP/1.1 的问题</p><ol><li><p>队头阻塞 在 HTTP 请求应答过程中，如果出现了某种情况，导致响应一直未能完成，那后面所有的请求就会一直阻塞着，这种情况叫队头阻塞。</p></li><li><p>低效的 TCP 利用 由于 TCP 慢启动机制，导致每个 TCP 连接在一开始的时候传输速率都不高，在处理多个请求后，才会慢慢达到“合适”的速率。对于请求数据量很小的 HTTP 请求来说，这种情况就是种灾难。</p></li><li><p>臃肿的消息首部 HTTP/1.1 的首部无法压缩，再加上 cookie 的存在，经常会出现首部大小比请求数据大小还大的情况。</p></li><li><p>受限的优先级设置 HTTP/1.1 无法为重要的资源指定优先级，每个 HTTP 请求都是一视同仁。</p></li></ol><p>2、静态资源使用 CDN</p><p>内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。</p><p>用户访问的网站部署了 CDN，过程是这样的：</p><ol><li>浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。</li><li>本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。</li><li>本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。</li><li>本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。</li><li>SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。</li><li>浏览器再根据 SLB 发回的地址重定向到缓存服务器。</li><li>如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。</li></ol><p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67c19972e7dd4ae0840a0f838dd6a017~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" target="_blank" rel="noreferrer">DNS流程</a></p><p>3、压缩文件</p><p>压缩文件可以减少文件下载时间，让用户体验性更好。</p><p>gzip 是目前最流行和最有效的压缩方法。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。</p><p>举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。</p><p>4、通过 max-age 和 no-cache 实现文件精确缓存</p><p>通用消息头部 Cache-Control 其中有两个选项：</p><p>max-age: 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。在这个时间前，浏览器读取文件不会发出新请求，而是直接使用缓存。 no-cache: 指定 no-cache 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。 我们可以将那些长期不变的静态资源设置一个非常长的缓存时间，例如设置成缓存一年。</p><p>然后将 index.html 文件设置成 no-cache。这样每次访问网站时，浏览器都会询问 index.html 是否有更新，如果没有，就使用旧的 index.html 文件。如果有更新，就读取新的 index.html 文件。当加载新的 index.html 时，也会去加载里面新的 URL 资源。</p><p>例如 index.html 原来引用了 a.js 和 b.js，现在更新了变成 a.js 和 c.js。那就只会加载 c.js 文件。</p><p>4、异步加载代码，提取公共库</p><p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。</p><p>a. 路由页面通过import方式异步引入，在webpack打包构建时会单独打包成一个chunk,只有在需要加载当前页面时才会访问此页面的js</p><p>b. 提取第三方库</p>',24),o=[n];function c(l,r,d,s,_,h){return a(),e("div",null,o)}const S=p(t,[["render",c]]);export{m as __pageData,S as default};
